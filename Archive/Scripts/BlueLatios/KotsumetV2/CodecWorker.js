/* eslint-disable */
var wasm = null; try { wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports } catch { } function Long(e, t, r) { this.low = e | 0, this.high = t | 0, this.unsigned = !!r } Long.prototype.__isLong__, Object.defineProperty(Long.prototype, "__isLong__", { value: !0 }); function isLong(e) { return (e && e.__isLong__) === !0 } function ctz32(e) { var t = Math.clz32(e & -e); return e ? 31 - t : t } Long.isLong = isLong; var INT_CACHE = {}, UINT_CACHE = {}; function fromInt(e, t) { var r, n, h; return t ? (e >>>= 0, (h = 0 <= e && e < 256) && (n = UINT_CACHE[e], n) ? n : (r = fromBits(e, 0, !0), h && (UINT_CACHE[e] = r), r)) : (e |= 0, (h = -128 <= e && e < 128) && (n = INT_CACHE[e], n) ? n : (r = fromBits(e, e < 0 ? -1 : 0, !1), h && (INT_CACHE[e] = r), r)) } Long.fromInt = fromInt; function fromNumber(e, t) { if (isNaN(e)) return t ? UZERO : ZERO; if (t) { if (e < 0) return UZERO; if (e >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE } else { if (e <= -TWO_PWR_63_DBL) return MIN_VALUE; if (e + 1 >= TWO_PWR_63_DBL) return MAX_VALUE } return e < 0 ? fromNumber(-e, t).neg() : fromBits(e % TWO_PWR_32_DBL | 0, e / TWO_PWR_32_DBL | 0, t) } Long.fromNumber = fromNumber; function fromBits(e, t, r) { return new Long(e, t, r) } Long.fromBits = fromBits; var pow_dbl = Math.pow; function fromString(e, t, r) { if (e.length === 0) throw Error("empty string"); if (typeof t == "number" ? (r = t, t = !1) : t = !!t, e === "NaN" || e === "Infinity" || e === "+Infinity" || e === "-Infinity") return t ? UZERO : ZERO; if (r = r || 10, r < 2 || 36 < r) throw RangeError("radix"); var n; if ((n = e.indexOf("-")) > 0) throw Error("interior hyphen"); if (n === 0) return fromString(e.substring(1), t, r).neg(); for (var h = fromNumber(pow_dbl(r, 8)), s = ZERO, a = 0; a < e.length; a += 8) { var l = Math.min(8, e.length - a), o = parseInt(e.substring(a, a + l), r); if (l < 8) { var g = fromNumber(pow_dbl(r, l)); s = s.mul(g).add(fromNumber(o)) } else s = s.mul(h), s = s.add(fromNumber(o)) } return s.unsigned = t, s } Long.fromString = fromString; function fromValue(e, t) { return typeof e == "number" ? fromNumber(e, t) : typeof e == "string" ? fromString(e, t) : fromBits(e.low, e.high, typeof t == "boolean" ? t : e.unsigned) } Long.fromValue = fromValue; var TWO_PWR_16_DBL = 65536, TWO_PWR_24_DBL = 1 << 24, TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL, TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL, TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2, TWO_PWR_24 = fromInt(TWO_PWR_24_DBL), ZERO = fromInt(0); Long.ZERO = ZERO; var UZERO = fromInt(0, !0); Long.UZERO = UZERO; var ONE = fromInt(1); Long.ONE = ONE; var UONE = fromInt(1, !0); Long.UONE = UONE; var NEG_ONE = fromInt(-1); Long.NEG_ONE = NEG_ONE; var MAX_VALUE = fromBits(-1, 2147483647, !1); Long.MAX_VALUE = MAX_VALUE; var MAX_UNSIGNED_VALUE = fromBits(-1, -1, !0); Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE; var MIN_VALUE = fromBits(0, -2147483648, !1); Long.MIN_VALUE = MIN_VALUE; var LongPrototype = Long.prototype; LongPrototype.toInt = function () { return this.unsigned ? this.low >>> 0 : this.low }, LongPrototype.toNumber = function () { return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (this.low >>> 0) }, LongPrototype.toString = function (t) { if (t = t || 10, t < 2 || 36 < t) throw RangeError("radix"); if (this.isZero()) return "0"; if (this.isNegative()) if (this.eq(MIN_VALUE)) { var r = fromNumber(t), n = this.div(r), h = n.mul(r).sub(this); return n.toString(t) + h.toInt().toString(t) } else return "-" + this.neg().toString(t); for (var s = fromNumber(pow_dbl(t, 6), this.unsigned), a = this, l = ""; ;) { var o = a.div(s), g = a.sub(o.mul(s)).toInt() >>> 0, u = g.toString(t); if (a = o, a.isZero()) return u + l; for (; u.length < 6;)u = "0" + u; l = "" + u + l } }, LongPrototype.getHighBits = function () { return this.high }, LongPrototype.getHighBitsUnsigned = function () { return this.high >>> 0 }, LongPrototype.getLowBits = function () { return this.low }, LongPrototype.getLowBitsUnsigned = function () { return this.low >>> 0 }, LongPrototype.getNumBitsAbs = function () { if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs(); for (var t = this.high != 0 ? this.high : this.low, r = 31; r > 0 && !(t & 1 << r); r--); return this.high != 0 ? r + 33 : r + 1 }, LongPrototype.isZero = function () { return this.high === 0 && this.low === 0 }, LongPrototype.eqz = LongPrototype.isZero, LongPrototype.isNegative = function () { return !this.unsigned && this.high < 0 }, LongPrototype.isPositive = function () { return this.unsigned || this.high >= 0 }, LongPrototype.isOdd = function () { return (this.low & 1) === 1 }, LongPrototype.isEven = function () { return (this.low & 1) === 0 }, LongPrototype.equals = function (t) { return isLong(t) || (t = fromValue(t)), this.unsigned !== t.unsigned && this.high >>> 31 === 1 && t.high >>> 31 === 1 ? !1 : this.high === t.high && this.low === t.low }, LongPrototype.eq = LongPrototype.equals, LongPrototype.notEquals = function (t) { return !this.eq(t) }, LongPrototype.neq = LongPrototype.notEquals, LongPrototype.ne = LongPrototype.notEquals, LongPrototype.lessThan = function (t) { return this.comp(t) < 0 }, LongPrototype.lt = LongPrototype.lessThan, LongPrototype.lessThanOrEqual = function (t) { return this.comp(t) <= 0 }, LongPrototype.lte = LongPrototype.lessThanOrEqual, LongPrototype.le = LongPrototype.lessThanOrEqual, LongPrototype.greaterThan = function (t) { return this.comp(t) > 0 }, LongPrototype.gt = LongPrototype.greaterThan, LongPrototype.greaterThanOrEqual = function (t) { return this.comp(t) >= 0 }, LongPrototype.gte = LongPrototype.greaterThanOrEqual, LongPrototype.ge = LongPrototype.greaterThanOrEqual, LongPrototype.compare = function (t) { if (isLong(t) || (t = fromValue(t)), this.eq(t)) return 0; var r = this.isNegative(), n = t.isNegative(); return r && !n ? -1 : !r && n ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1 }, LongPrototype.comp = LongPrototype.compare, LongPrototype.negate = function () { return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE) }, LongPrototype.neg = LongPrototype.negate, LongPrototype.add = function (t) { isLong(t) || (t = fromValue(t)); var r = this.high >>> 16, n = this.high & 65535, h = this.low >>> 16, s = this.low & 65535, a = t.high >>> 16, l = t.high & 65535, o = t.low >>> 16, g = t.low & 65535, u = 0, c = 0, f = 0, y = 0; return y += s + g, f += y >>> 16, y &= 65535, f += h + o, c += f >>> 16, f &= 65535, c += n + l, u += c >>> 16, c &= 65535, u += r + a, u &= 65535, fromBits(f << 16 | y, u << 16 | c, this.unsigned) }, LongPrototype.subtract = function (t) { return isLong(t) || (t = fromValue(t)), this.add(t.neg()) }, LongPrototype.sub = LongPrototype.subtract, LongPrototype.multiply = function (t) { if (this.isZero()) return this; if (isLong(t) || (t = fromValue(t)), wasm) { var r = wasm.mul(this.low, this.high, t.low, t.high); return fromBits(r, wasm.get_high(), this.unsigned) } if (t.isZero()) return this.unsigned ? UZERO : ZERO; if (this.eq(MIN_VALUE)) return t.isOdd() ? MIN_VALUE : ZERO; if (t.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO; if (this.isNegative()) return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg(); if (t.isNegative()) return this.mul(t.neg()).neg(); if (this.lt(TWO_PWR_24) && t.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * t.toNumber(), this.unsigned); var n = this.high >>> 16, h = this.high & 65535, s = this.low >>> 16, a = this.low & 65535, l = t.high >>> 16, o = t.high & 65535, g = t.low >>> 16, u = t.low & 65535, c = 0, f = 0, y = 0, w = 0; return w += a * u, y += w >>> 16, w &= 65535, y += s * u, f += y >>> 16, y &= 65535, y += a * g, f += y >>> 16, y &= 65535, f += h * u, c += f >>> 16, f &= 65535, f += s * g, c += f >>> 16, f &= 65535, f += a * o, c += f >>> 16, f &= 65535, c += n * u + h * g + s * o + a * l, c &= 65535, fromBits(y << 16 | w, c << 16 | f, this.unsigned) }, LongPrototype.mul = LongPrototype.multiply, LongPrototype.divide = function (t) { if (isLong(t) || (t = fromValue(t)), t.isZero()) throw Error("division by zero"); if (wasm) { if (!this.unsigned && this.high === -2147483648 && t.low === -1 && t.high === -1) return this; var r = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, t.low, t.high); return fromBits(r, wasm.get_high(), this.unsigned) } if (this.isZero()) return this.unsigned ? UZERO : ZERO; var n, h, s; if (this.unsigned) { if (t.unsigned || (t = t.toUnsigned()), t.gt(this)) return UZERO; if (t.gt(this.shru(1))) return UONE; s = UZERO } else { if (this.eq(MIN_VALUE)) { if (t.eq(ONE) || t.eq(NEG_ONE)) return MIN_VALUE; if (t.eq(MIN_VALUE)) return ONE; var a = this.shr(1); return n = a.div(t).shl(1), n.eq(ZERO) ? t.isNegative() ? ONE : NEG_ONE : (h = this.sub(t.mul(n)), s = n.add(h.div(t)), s) } else if (t.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO; if (this.isNegative()) return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg(); if (t.isNegative()) return this.div(t.neg()).neg(); s = ZERO } for (h = this; h.gte(t);) { n = Math.max(1, Math.floor(h.toNumber() / t.toNumber())); for (var l = Math.ceil(Math.log(n) / Math.LN2), o = l <= 48 ? 1 : pow_dbl(2, l - 48), g = fromNumber(n), u = g.mul(t); u.isNegative() || u.gt(h);)n -= o, g = fromNumber(n, this.unsigned), u = g.mul(t); g.isZero() && (g = ONE), s = s.add(g), h = h.sub(u) } return s }, LongPrototype.div = LongPrototype.divide, LongPrototype.modulo = function (t) { if (isLong(t) || (t = fromValue(t)), wasm) { var r = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, t.low, t.high); return fromBits(r, wasm.get_high(), this.unsigned) } return this.sub(this.div(t).mul(t)) }, LongPrototype.mod = LongPrototype.modulo, LongPrototype.rem = LongPrototype.modulo, LongPrototype.not = function () { return fromBits(~this.low, ~this.high, this.unsigned) }, LongPrototype.countLeadingZeros = function () { return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32 }, LongPrototype.clz = LongPrototype.countLeadingZeros, LongPrototype.countTrailingZeros = function () { return this.low ? ctz32(this.low) : ctz32(this.high) + 32 }, LongPrototype.ctz = LongPrototype.countTrailingZeros, LongPrototype.and = function (t) { return isLong(t) || (t = fromValue(t)), fromBits(this.low & t.low, this.high & t.high, this.unsigned) }, LongPrototype.or = function (t) { return isLong(t) || (t = fromValue(t)), fromBits(this.low | t.low, this.high | t.high, this.unsigned) }, LongPrototype.xor = function (t) { return isLong(t) || (t = fromValue(t)), fromBits(this.low ^ t.low, this.high ^ t.high, this.unsigned) }, LongPrototype.shiftLeft = function (t) { return isLong(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? fromBits(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : fromBits(0, this.low << t - 32, this.unsigned) }, LongPrototype.shl = LongPrototype.shiftLeft, LongPrototype.shiftRight = function (t) { return isLong(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? fromBits(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : fromBits(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned) }, LongPrototype.shr = LongPrototype.shiftRight, LongPrototype.shiftRightUnsigned = function (t) { return isLong(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? fromBits(this.low >>> t | this.high << 32 - t, this.high >>> t, this.unsigned) : t === 32 ? fromBits(this.high, 0, this.unsigned) : fromBits(this.high >>> t - 32, 0, this.unsigned) }, LongPrototype.shru = LongPrototype.shiftRightUnsigned, LongPrototype.shr_u = LongPrototype.shiftRightUnsigned, LongPrototype.rotateLeft = function (t) { var r; return isLong(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? fromBits(this.high, this.low, this.unsigned) : t < 32 ? (r = 32 - t, fromBits(this.low << t | this.high >>> r, this.high << t | this.low >>> r, this.unsigned)) : (t -= 32, r = 32 - t, fromBits(this.high << t | this.low >>> r, this.low << t | this.high >>> r, this.unsigned)) }, LongPrototype.rotl = LongPrototype.rotateLeft, LongPrototype.rotateRight = function (t) { var r; return isLong(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? fromBits(this.high, this.low, this.unsigned) : t < 32 ? (r = 32 - t, fromBits(this.high << r | this.low >>> t, this.low << r | this.high >>> t, this.unsigned)) : (t -= 32, r = 32 - t, fromBits(this.low << r | this.high >>> t, this.high << r | this.low >>> t, this.unsigned)) }, LongPrototype.rotr = LongPrototype.rotateRight, LongPrototype.toSigned = function () { return this.unsigned ? fromBits(this.low, this.high, !1) : this }, LongPrototype.toUnsigned = function () { return this.unsigned ? this : fromBits(this.low, this.high, !0) }, LongPrototype.toBytes = function (t) { return t ? this.toBytesLE() : this.toBytesBE() }, LongPrototype.toBytesLE = function () { var t = this.high, r = this.low; return [r & 255, r >>> 8 & 255, r >>> 16 & 255, r >>> 24, t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24] }, LongPrototype.toBytesBE = function () { var t = this.high, r = this.low; return [t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255, r >>> 24, r >>> 16 & 255, r >>> 8 & 255, r & 255] }, Long.fromBytes = function (t, r, n) { return n ? Long.fromBytesLE(t, r) : Long.fromBytesBE(t, r) }, Long.fromBytesLE = function (t, r) { return new Long(t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24, t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24, r) }, Long.fromBytesBE = function (t, r) { return new Long(t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7], t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3], r) }; class ByteBuffer { constructor(t, r, n) { if (typeof t > "u" && (t = ByteBuffer.DEFAULT_CAPACITY), typeof r > "u" && (r = ByteBuffer.DEFAULT_ENDIAN), typeof n > "u" && (n = ByteBuffer.DEFAULT_NOASSERT), !n) { if (t = t | 0, t < 0) throw RangeError("Illegal capacity"); r = !!r, n = !!n } this.buffer = t === 0 ? EMPTY_BUFFER : new ArrayBuffer(t), this.view = t === 0 ? null : new Uint8Array(this.buffer), this.offset = 0, this.markedOffset = -1, this.limit = t, this.littleEndian = r, this.noAssert = n } static accessor() { return Uint8Array } static allocate(t, r, n) { return new ByteBuffer(t, r, n) } static concat(t, r, n, h) { (typeof r == "boolean" || typeof r != "string") && (h = n, n = r, r = void 0); let s = 0; for (let o = 0, g = t.length, u; o < g; ++o)ByteBuffer.isByteBuffer(t[o]) || (t[o] = ByteBuffer.wrap(t[o], r)), u = t[o].limit - t[o].offset, u > 0 && (s += u); if (s === 0) return new ByteBuffer(0, n, h); let a = new ByteBuffer(s, n, h), l; for (i = 0; i < k;)l = t[i++], length = l.limit - l.offset, !(length <= 0) && (a.view.set(l.view.subarray(l.offset, l.limit), a.offset), a.offset += length); return a.limit = a.offset, a.offset = 0, a } static isByteBuffer(t) { return (t && t.__isByteBuffer__) === !0 } static type() { return ArrayBuffer } static wrap(t, r, n, h) { if (typeof r != "string" && (h = n, n = r, r = void 0), typeof t == "string") switch (typeof r > "u" && (r = "utf8"), r) { case "base64": return ByteBuffer.fromBase64(t, n); case "hex": return ByteBuffer.fromHex(t, n); case "binary": return ByteBuffer.fromBinary(t, n); case "utf8": return ByteBuffer.fromUTF8(t, n); case "debug": return ByteBuffer.fromDebug(t, n); default: throw Error(`Unsupported encoding: ${r}`) }if (t === null || typeof t != "object") throw TypeError("Illegal buffer"); let s; if (ByteBuffer.isByteBuffer(t)) return s = ByteBufferPrototype.clone.call(t), s.markedOffset = -1, s; if (t instanceof Uint8Array) s = new ByteBuffer(0, n, h), t.length > 0 && (s.buffer = t.buffer, s.offset = t.byteOffset, s.limit = t.byteOffset + t.byteLength, s.view = new Uint8Array(t.buffer)); else if (t instanceof ArrayBuffer) s = new ByteBuffer(0, n, h), t.byteLength > 0 && (s.buffer = t, s.offset = 0, s.limit = t.byteLength, s.view = t.byteLength > 0 ? new Uint8Array(t) : null); else if (Object.prototype.toString.call(t) === "[object Array]") { s = new ByteBuffer(t.length, n, h), s.limit = t.length; for (let a = 0; a < t.length; ++a)s.view[a] = t[a] } else throw TypeError("Illegal buffer"); return s } static calculateVarint32(t) { return t = t >>> 0, t < 128 ? 1 : t < 16384 ? 2 : t < 1 << 21 ? 3 : t < 1 << 28 ? 4 : 5 } static zigZagEncode32(t) { return ((t |= 0) << 1 ^ t >> 31) >>> 0 } static zigZagDecode32(t) { return t >>> 1 ^ -(t & 1) | 0 } static calculateVarint64(t) { typeof t == "number" ? t = Long.fromNumber(t) : typeof t == "string" && (t = Long.fromString(t)); const r = t.toInt() >>> 0, n = t.shiftRightUnsigned(28).toInt() >>> 0, h = t.shiftRightUnsigned(56).toInt() >>> 0; return h == 0 ? n == 0 ? r < 16384 ? r < 128 ? 1 : 2 : r < 1 << 21 ? 3 : 4 : n < 16384 ? n < 128 ? 5 : 6 : n < 1 << 21 ? 7 : 8 : h < 128 ? 9 : 10 } static zigZagEncode64(t) { return typeof t == "number" ? t = Long.fromNumber(t, !1) : typeof t == "string" ? t = Long.fromString(t, !1) : t.unsigned !== !1 && (t = t.toSigned()), t.shiftLeft(1).xor(t.shiftRight(63)).toUnsigned() } static zigZagDecode64(t) { return typeof t == "number" ? t = Long.fromNumber(t, !1) : typeof t == "string" ? t = Long.fromString(t, !1) : t.unsigned !== !1 && (t = t.toSigned()), t.shiftRightUnsigned(1).xor(t.and(Long.ONE).toSigned().negate()).toSigned() } static calculateUTF8Chars(t) { return utfx.calculateUTF16asUTF8(stringSource(t))[0] } static calculateUTF8Bytes(t) { return utfx.calculateUTF16asUTF8(stringSource(t))[1] } static fromBase64(t, r) { if (typeof t != "string") throw TypeError("str"); const n = new ByteBuffer(t.length / 4 * 3, r); let h = 0; return lxiv.decode(stringSource(t), function (s) { n.view[h++] = s }), n.limit = h, n } static btoa(t) { return ByteBuffer.fromBinary(t).toBase64() } static atob(t) { return ByteBuffer.fromBase64(t).toBinary() } static fromBinary(t, r) { if (typeof t != "string") throw TypeError("str"); let n = 0, h; const s = t.length, a = new ByteBuffer(s, r); for (; n < s;) { if (h = t.charCodeAt(n), h > 255) throw RangeError(`illegal char code: ${h}`); a.view[n++] = h } return a.limit = s, a } static fromDebug(t, r, n) { const h = t.length, s = new ByteBuffer((h + 1) / 3 | 0, r, n); let a = 0, l = 0, o, g, u = !1, c = !1, f = !1, y = !1, w = !1; for (; a < h;) { switch (o = t.charAt(a++)) { case "!": if (!n) { if (c || f || y) { w = !0; break } c = f = y = !0 } s.offset = s.markedOffset = s.limit = l, u = !1; break; case "|": if (!n) { if (c || y) { w = !0; break } c = y = !0 } s.offset = s.limit = l, u = !1; break; case "[": if (!n) { if (c || f) { w = !0; break } c = f = !0 } s.offset = s.markedOffset = l, u = !1; break; case "<": if (!n) { if (c) { w = !0; break } c = !0 } s.offset = l, u = !1; break; case "]": if (!n) { if (y || f) { w = !0; break } y = f = !0 } s.limit = s.markedOffset = l, u = !1; break; case ">": if (!n) { if (y) { w = !0; break } y = !0 } s.limit = l, u = !1; break; case "'": if (!n) { if (f) { w = !0; break } f = !0 } s.markedOffset = l, u = !1; break; case " ": u = !1; break; default: if (!n && u) { w = !0; break } if (g = parseInt(o + t.charAt(a++), 16), !n && (isNaN(g) || g < 0 || g > 255)) throw TypeError("Illegal str: Not a debug encoded string"); s.view[l++] = g, u = !0 }if (w) throw TypeError(`Illegal str: Invalid symbol at ${a}`) } if (!n) { if (!c || !y) throw TypeError("Illegal str: Missing offset or limit"); if (l < s.buffer.byteLength) throw TypeError(`Illegal str: Not a debug encoded string (is it hex?) ${l} < ${h}`) } return s } static fromHex(t, r, n) { if (!n) { if (typeof t != "string") throw TypeError("Illegal str: Not a string"); if (t.length % 2 !== 0) throw TypeError("Illegal str: Length not a multiple of 2") } let h = t.length, s = new ByteBuffer(h / 2 | 0, r), a; for (var l = 0, o = 0; l < h; l += 2) { if (a = parseInt(t.substring(l, l + 2), 16), !n && (!isFinite(a) || a < 0 || a > 255)) throw TypeError("Illegal str: Contains non-hex characters"); s.view[o++] = a } return s.limit = o, s } static fromUTF8(t, r, n) { if (!n && typeof t != "string") throw TypeError("Illegal str: Not a string"); let h = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(t), !0)[1], r, n), s = 0; return utfx.encodeUTF16toUTF8(stringSource(t), function (a) { h.view[s++] = a }), h.limit = s, h } } ByteBuffer.VERSION = "5.0.1", ByteBuffer.LITTLE_ENDIAN = !0, ByteBuffer.BIG_ENDIAN = !1, ByteBuffer.DEFAULT_CAPACITY = 16, ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN, ByteBuffer.DEFAULT_NOASSERT = !1, ByteBuffer.Long = Long || null; const ByteBufferPrototype = ByteBuffer.prototype; ByteBufferPrototype.__isByteBuffer__, Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", { value: !0, enumerable: !1, configurable: !1 }); const EMPTY_BUFFER = new ArrayBuffer(0), stringFromCharCode = String.fromCharCode; function stringSource(e) { let t = 0; return function () { return t < e.length ? e.charCodeAt(t++) : null } } function stringDestination() { const e = [], t = []; return function () { if (arguments.length === 0) return t.join("") + stringFromCharCode.apply(String, e); e.length + arguments.length > 1024 && (t.push(stringFromCharCode.apply(String, e)), e.length = 0), Array.prototype.push.apply(e, arguments) } } ByteBufferPrototype.writeBitSet = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (!(e instanceof Array)) throw TypeError("Illegal BitSet: Not an array"); if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } let n = t, h = e.length, s = h >> 3, a = 0, l; for (t += this.writeVarint32(h, t); s--;)l = !!e[a++] & 1 | (!!e[a++] & 1) << 1 | (!!e[a++] & 1) << 2 | (!!e[a++] & 1) << 3 | (!!e[a++] & 1) << 4 | (!!e[a++] & 1) << 5 | (!!e[a++] & 1) << 6 | (!!e[a++] & 1) << 7, this.writeByte(l, t++); if (a < h) { let o = 0; for (l = 0; a < h;)l = l | (!!e[a++] & 1) << o++; this.writeByte(l, t++) } return r ? (this.offset = t, this) : t - n }, ByteBufferPrototype.readBitSet = function (e) { const t = typeof e > "u"; t && (e = this.offset); let r = this.readVarint32(e), n = r.value, h = n >> 3, s = 0, a = [], l; for (e += r.length; h--;)l = this.readByte(e++), a[s++] = !!(l & 1), a[s++] = !!(l & 2), a[s++] = !!(l & 4), a[s++] = !!(l & 8), a[s++] = !!(l & 16), a[s++] = !!(l & 32), a[s++] = !!(l & 64), a[s++] = !!(l & 128); if (s < n) { let o = 0; for (l = this.readByte(e++); s < n;)a[s++] = !!(l >> o++ & 1) } return t && (this.offset = e), a }, ByteBufferPrototype.readBytes = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + e > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+${e}) <= ${this.buffer.byteLength}`) } const n = this.slice(t, t + e); return r && (this.offset += e), n }, ByteBufferPrototype.writeInt8 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal value: ${e} (not an integer)`); if (e |= 0, typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } t += 1; let n = this.buffer.byteLength; return t > n && this.resize((n *= 2) > t ? n : t), t -= 1, this.view[t] = e, r && (this.offset += 1), this }, ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8, ByteBufferPrototype.readInt8 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+1) <= ${this.buffer.byteLength}`) } let r = this.view[e]; return (r & 128) === 128 && (r = -(255 - r + 1)), t && (this.offset += 1), r }, ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8, ByteBufferPrototype.writeUint8 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal value: ${e} (not an integer)`); if (e >>>= 0, typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } t += 1; let n = this.buffer.byteLength; return t > n && this.resize((n *= 2) > t ? n : t), t -= 1, this.view[t] = e, r && (this.offset += 1), this }, ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8, ByteBufferPrototype.readUint8 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+1) <= ${this.buffer.byteLength}`) } const r = this.view[e]; return t && (this.offset += 1), r }, ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8, ByteBufferPrototype.writeInt16 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal value: ${e} (not an integer)`); if (e |= 0, typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } t += 2; let n = this.buffer.byteLength; return t > n && this.resize((n *= 2) > t ? n : t), t -= 2, this.littleEndian ? (this.view[t + 1] = (e & 65280) >>> 8, this.view[t] = e & 255) : (this.view[t] = (e & 65280) >>> 8, this.view[t + 1] = e & 255), r && (this.offset += 2), this }, ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16, ByteBufferPrototype.readInt16 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 2 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+2) <= ${this.buffer.byteLength}`) } let r = 0; return this.littleEndian ? (r = this.view[e], r |= this.view[e + 1] << 8) : (r = this.view[e] << 8, r |= this.view[e + 1]), (r & 32768) === 32768 && (r = -(65535 - r + 1)), t && (this.offset += 2), r }, ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16, ByteBufferPrototype.writeUint16 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal value: ${e} (not an integer)`); if (e >>>= 0, typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } t += 2; let n = this.buffer.byteLength; return t > n && this.resize((n *= 2) > t ? n : t), t -= 2, this.littleEndian ? (this.view[t + 1] = (e & 65280) >>> 8, this.view[t] = e & 255) : (this.view[t] = (e & 65280) >>> 8, this.view[t + 1] = e & 255), r && (this.offset += 2), this }, ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16, ByteBufferPrototype.readUint16 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 2 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+2) <= ${this.buffer.byteLength}`) } let r = 0; return this.littleEndian ? (r = this.view[e], r |= this.view[e + 1] << 8) : (r = this.view[e] << 8, r |= this.view[e + 1]), t && (this.offset += 2), r }, ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16, ByteBufferPrototype.writeInt32 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal value: ${e} (not an integer)`); if (e |= 0, typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } t += 4; let n = this.buffer.byteLength; return t > n && this.resize((n *= 2) > t ? n : t), t -= 4, this.littleEndian ? (this.view[t + 3] = e >>> 24 & 255, this.view[t + 2] = e >>> 16 & 255, this.view[t + 1] = e >>> 8 & 255, this.view[t] = e & 255) : (this.view[t] = e >>> 24 & 255, this.view[t + 1] = e >>> 16 & 255, this.view[t + 2] = e >>> 8 & 255, this.view[t + 3] = e & 255), r && (this.offset += 4), this }, ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32, ByteBufferPrototype.readInt32 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 4 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+4) <= ${this.buffer.byteLength}`) } let r = 0; return this.littleEndian ? (r = this.view[e + 2] << 16, r |= this.view[e + 1] << 8, r |= this.view[e], r += this.view[e + 3] << 24 >>> 0) : (r = this.view[e + 1] << 16, r |= this.view[e + 2] << 8, r |= this.view[e + 3], r += this.view[e] << 24 >>> 0), r |= 0, t && (this.offset += 4), r }, ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32, ByteBufferPrototype.writeUint32 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal value: ${e} (not an integer)`); if (e >>>= 0, typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } t += 4; let n = this.buffer.byteLength; return t > n && this.resize((n *= 2) > t ? n : t), t -= 4, this.littleEndian ? (this.view[t + 3] = e >>> 24 & 255, this.view[t + 2] = e >>> 16 & 255, this.view[t + 1] = e >>> 8 & 255, this.view[t] = e & 255) : (this.view[t] = e >>> 24 & 255, this.view[t + 1] = e >>> 16 & 255, this.view[t + 2] = e >>> 8 & 255, this.view[t + 3] = e & 255), r && (this.offset += 4), this }, ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32, ByteBufferPrototype.readUint32 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 4 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+4) <= ${this.buffer.byteLength}`) } let r = 0; return this.littleEndian ? (r = this.view[e + 2] << 16, r |= this.view[e + 1] << 8, r |= this.view[e], r += this.view[e + 3] << 24 >>> 0) : (r = this.view[e + 1] << 16, r |= this.view[e + 2] << 8, r |= this.view[e + 3], r += this.view[e] << 24 >>> 0), t && (this.offset += 4), r }, ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32, Long && (ByteBufferPrototype.writeInt64 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e == "number") e = Long.fromNumber(e); else if (typeof e == "string") e = Long.fromString(e); else if (!(e && e instanceof Long)) throw TypeError(`Illegal value: ${e} (not an integer or Long)`); if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } typeof e == "number" ? e = Long.fromNumber(e) : typeof e == "string" && (e = Long.fromString(e)), t += 8; let n = this.buffer.byteLength; t > n && this.resize((n *= 2) > t ? n : t), t -= 8; const h = e.low, s = e.high; return this.littleEndian ? (this.view[t + 3] = h >>> 24 & 255, this.view[t + 2] = h >>> 16 & 255, this.view[t + 1] = h >>> 8 & 255, this.view[t] = h & 255, t += 4, this.view[t + 3] = s >>> 24 & 255, this.view[t + 2] = s >>> 16 & 255, this.view[t + 1] = s >>> 8 & 255, this.view[t] = s & 255) : (this.view[t] = s >>> 24 & 255, this.view[t + 1] = s >>> 16 & 255, this.view[t + 2] = s >>> 8 & 255, this.view[t + 3] = s & 255, t += 4, this.view[t] = h >>> 24 & 255, this.view[t + 1] = h >>> 16 & 255, this.view[t + 2] = h >>> 8 & 255, this.view[t + 3] = h & 255), r && (this.offset += 8), this }, ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64, ByteBufferPrototype.readInt64 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 8 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+8) <= ${this.buffer.byteLength}`) } let r = 0, n = 0; this.littleEndian ? (r = this.view[e + 2] << 16, r |= this.view[e + 1] << 8, r |= this.view[e], r += this.view[e + 3] << 24 >>> 0, e += 4, n = this.view[e + 2] << 16, n |= this.view[e + 1] << 8, n |= this.view[e], n += this.view[e + 3] << 24 >>> 0) : (n = this.view[e + 1] << 16, n |= this.view[e + 2] << 8, n |= this.view[e + 3], n += this.view[e] << 24 >>> 0, e += 4, r = this.view[e + 1] << 16, r |= this.view[e + 2] << 8, r |= this.view[e + 3], r += this.view[e] << 24 >>> 0); const h = new Long(r, n, !1); return t && (this.offset += 8), h }, ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64, ByteBufferPrototype.writeUint64 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e == "number") e = Long.fromNumber(e); else if (typeof e == "string") e = Long.fromString(e); else if (!(e && e instanceof Long)) throw TypeError(`Illegal value: ${e} (not an integer or Long)`); if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } typeof e == "number" ? e = Long.fromNumber(e) : typeof e == "string" && (e = Long.fromString(e)), t += 8; let n = this.buffer.byteLength; t > n && this.resize((n *= 2) > t ? n : t), t -= 8; const h = e.low, s = e.high; return this.littleEndian ? (this.view[t + 3] = h >>> 24 & 255, this.view[t + 2] = h >>> 16 & 255, this.view[t + 1] = h >>> 8 & 255, this.view[t] = h & 255, t += 4, this.view[t + 3] = s >>> 24 & 255, this.view[t + 2] = s >>> 16 & 255, this.view[t + 1] = s >>> 8 & 255, this.view[t] = s & 255) : (this.view[t] = s >>> 24 & 255, this.view[t + 1] = s >>> 16 & 255, this.view[t + 2] = s >>> 8 & 255, this.view[t + 3] = s & 255, t += 4, this.view[t] = h >>> 24 & 255, this.view[t + 1] = h >>> 16 & 255, this.view[t + 2] = h >>> 8 & 255, this.view[t + 3] = h & 255), r && (this.offset += 8), this }, ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64, ByteBufferPrototype.readUint64 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 8 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+8) <= ${this.buffer.byteLength}`) } let r = 0, n = 0; this.littleEndian ? (r = this.view[e + 2] << 16, r |= this.view[e + 1] << 8, r |= this.view[e], r += this.view[e + 3] << 24 >>> 0, e += 4, n = this.view[e + 2] << 16, n |= this.view[e + 1] << 8, n |= this.view[e], n += this.view[e + 3] << 24 >>> 0) : (n = this.view[e + 1] << 16, n |= this.view[e + 2] << 8, n |= this.view[e + 3], n += this.view[e] << 24 >>> 0, e += 4, r = this.view[e + 1] << 16, r |= this.view[e + 2] << 8, r |= this.view[e + 3], r += this.view[e] << 24 >>> 0); const h = new Long(r, n, !0); return t && (this.offset += 8), h }, ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64); function ieee754_read(e, t, r, n, h) { let s, a, l = h * 8 - n - 1, o = (1 << l) - 1, g = o >> 1, u = -7, c = r ? h - 1 : 0, f = r ? -1 : 1, y = e[t + c]; for (c += f, s = y & (1 << -u) - 1, y >>= -u, u += l; u > 0; s = s * 256 + e[t + c], c += f, u -= 8); for (a = s & (1 << -u) - 1, s >>= -u, u += n; u > 0; a = a * 256 + e[t + c], c += f, u -= 8); if (s === 0) s = 1 - g; else { if (s === o) return a ? NaN : (y ? -1 : 1) * (1 / 0); a = a + 2 ** n, s = s - g } return (y ? -1 : 1) * a * 2 ** (s - n) } function ieee754_write(e, t, r, n, h, s) { let a, l, o, g = s * 8 - h - 1, u = (1 << g) - 1, c = u >> 1, f = h === 23 ? 2 ** -24 - 2 ** -77 : 0, y = n ? 0 : s - 1, w = n ? 1 : -1, p = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (l = isNaN(t) ? 1 : 0, a = u) : (a = Math.floor(Math.log(t) / Math.LN2), t * (o = 2 ** -a) < 1 && (a--, o *= 2), a + c >= 1 ? t += f / o : t += f * 2 ** (1 - c), t * o >= 2 && (a++, o /= 2), a + c >= u ? (l = 0, a = u) : a + c >= 1 ? (l = (t * o - 1) * 2 ** h, a = a + c) : (l = t * 2 ** (c - 1) * 2 ** h, a = 0)); h >= 8; e[r + y] = l & 255, y += w, l /= 256, h -= 8); for (a = a << h | l, g += h; g > 0; e[r + y] = a & 255, y += w, a /= 256, g -= 8); e[r + y - w] |= p * 128 } ByteBufferPrototype.writeFloat32 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "number") throw TypeError(`Illegal value: ${e} (not a number)`); if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } t += 4; let n = this.buffer.byteLength; return t > n && this.resize((n *= 2) > t ? n : t), t -= 4, ieee754_write(this.view, e, t, this.littleEndian, 23, 4), r && (this.offset += 4), this }, ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32, ByteBufferPrototype.readFloat32 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 4 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+4) <= ${this.buffer.byteLength}`) } const r = ieee754_read(this.view, e, this.littleEndian, 23, 4); return t && (this.offset += 4), r }, ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32, ByteBufferPrototype.writeFloat64 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "number") throw TypeError(`Illegal value: ${e} (not a number)`); if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } t += 8; let n = this.buffer.byteLength; return t > n && this.resize((n *= 2) > t ? n : t), t -= 8, ieee754_write(this.view, e, t, this.littleEndian, 52, 8), r && (this.offset += 8), this }, ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64, ByteBufferPrototype.readFloat64 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 8 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+8) <= ${this.buffer.byteLength}`) } const r = ieee754_read(this.view, e, this.littleEndian, 52, 8); return t && (this.offset += 8), r }, ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64, ByteBuffer.MAX_VARINT32_BYTES = 5, ByteBufferPrototype.writeVarint32 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal value: ${e} (not an integer)`); if (e |= 0, typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } let n = ByteBuffer.calculateVarint32(e), h; t += n; let s = this.buffer.byteLength; for (t > s && this.resize((s *= 2) > t ? s : t), t -= n, e >>>= 0; e >= 128;)h = e & 127 | 128, this.view[t++] = h, e >>>= 7; return this.view[t++] = e, r ? (this.offset = t, this) : n }, ByteBufferPrototype.writeVarint32ZigZag = function (e, t) { return this.writeVarint32(ByteBuffer.zigZagEncode32(e), t) }, ByteBufferPrototype.readVarint32 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+1) <= ${this.buffer.byteLength}`) } let r = 0, n = 0, h; do { if (!this.noAssert && e > this.limit) { const s = Error("Truncated"); throw s.truncated = !0, s } h = this.view[e++], r < 5 && (n |= (h & 127) << 7 * r), ++r } while (h & 128); return n |= 0, t ? (this.offset = e, n) : { value: n, length: r } }, ByteBufferPrototype.readVarint32ZigZag = function (e) { let t = this.readVarint32(e); return typeof t == "object" ? t.value = ByteBuffer.zigZagDecode32(t.value) : t = ByteBuffer.zigZagDecode32(t), t }, Long && (ByteBuffer.MAX_VARINT64_BYTES = 10, ByteBufferPrototype.writeVarint64 = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e == "number") e = Long.fromNumber(e); else if (typeof e == "string") e = Long.fromString(e); else if (!(e && e instanceof Long)) throw TypeError(`Illegal value: ${e} (not an integer or Long)`); if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } typeof e == "number" ? e = Long.fromNumber(e, !1) : typeof e == "string" ? e = Long.fromString(e, !1) : e.unsigned !== !1 && (e = e.toSigned()); const n = ByteBuffer.calculateVarint64(e), h = e.toInt() >>> 0, s = e.shiftRightUnsigned(28).toInt() >>> 0, a = e.shiftRightUnsigned(56).toInt() >>> 0; t += n; let l = this.buffer.byteLength; switch (t > l && this.resize((l *= 2) > t ? l : t), t -= n, n) { case 10: this.view[t + 9] = a >>> 7 & 1; case 9: this.view[t + 8] = n !== 9 ? a | 128 : a & 127; case 8: this.view[t + 7] = n !== 8 ? s >>> 21 | 128 : s >>> 21 & 127; case 7: this.view[t + 6] = n !== 7 ? s >>> 14 | 128 : s >>> 14 & 127; case 6: this.view[t + 5] = n !== 6 ? s >>> 7 | 128 : s >>> 7 & 127; case 5: this.view[t + 4] = n !== 5 ? s | 128 : s & 127; case 4: this.view[t + 3] = n !== 4 ? h >>> 21 | 128 : h >>> 21 & 127; case 3: this.view[t + 2] = n !== 3 ? h >>> 14 | 128 : h >>> 14 & 127; case 2: this.view[t + 1] = n !== 2 ? h >>> 7 | 128 : h >>> 7 & 127; case 1: this.view[t] = n !== 1 ? h | 128 : h & 127 }return r ? (this.offset += n, this) : n }, ByteBufferPrototype.writeVarint64ZigZag = function (e, t) { return this.writeVarint64(ByteBuffer.zigZagEncode64(e), t) }, ByteBufferPrototype.readVarint64 = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+1) <= ${this.buffer.byteLength}`) } let r = e, n = 0, h = 0, s = 0, a = 0; if (a = this.view[e++], n = a & 127, a & 128 && (a = this.view[e++], n |= (a & 127) << 7, (a & 128 || this.noAssert && typeof a > "u") && (a = this.view[e++], n |= (a & 127) << 14, (a & 128 || this.noAssert && typeof a > "u") && (a = this.view[e++], n |= (a & 127) << 21, (a & 128 || this.noAssert && typeof a > "u") && (a = this.view[e++], h = a & 127, (a & 128 || this.noAssert && typeof a > "u") && (a = this.view[e++], h |= (a & 127) << 7, (a & 128 || this.noAssert && typeof a > "u") && (a = this.view[e++], h |= (a & 127) << 14, (a & 128 || this.noAssert && typeof a > "u") && (a = this.view[e++], h |= (a & 127) << 21, (a & 128 || this.noAssert && typeof a > "u") && (a = this.view[e++], s = a & 127, (a & 128 || this.noAssert && typeof a > "u") && (a = this.view[e++], s |= (a & 127) << 7, a & 128 || this.noAssert && typeof a > "u")))))))))) throw Error("Buffer overrun"); const l = Long.fromBits(n | h << 28, h >>> 4 | s << 24, !1); return t ? (this.offset = e, l) : { value: l, length: e - r } }, ByteBufferPrototype.readVarint64ZigZag = function (e) { let t = this.readVarint64(e); return t && t.value instanceof Long ? t.value = ByteBuffer.zigZagDecode64(t.value) : t = ByteBuffer.zigZagDecode64(t), t }), ByteBufferPrototype.writeCString = function (e, t) { const r = typeof t > "u"; r && (t = this.offset); let n, h = e.length; if (!this.noAssert) { if (typeof e != "string") throw TypeError("Illegal str: Not a string"); for (n = 0; n < h; ++n)if (e.charCodeAt(n) === 0) throw RangeError("Illegal str: Contains NULL-characters"); if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } h = utfx.calculateUTF16asUTF8(stringSource(e))[1], t += h + 1; let s = this.buffer.byteLength; return t > s && this.resize((s *= 2) > t ? s : t), t -= h + 1, utfx.encodeUTF16toUTF8(stringSource(e), function (a) { this.view[t++] = a }.bind(this)), this.view[t++] = 0, r ? (this.offset = t, this) : h }, ByteBufferPrototype.readCString = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+1) <= ${this.buffer.byteLength}`) } let r = e, n, h, s = -1; return utfx.decodeUTF8toUTF16(function () { if (s === 0) return null; if (e >= this.limit) throw RangeError(`Illegal range: Truncated data, ${e} < ${this.limit}`); return s = this.view[e++], s === 0 ? null : s }.bind(this), h = stringDestination(), !0), t ? (this.offset = e, h()) : { string: h(), length: e - r } }, ByteBufferPrototype.writeIString = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "string") throw TypeError("Illegal str: Not a string"); if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } let n = t, h; h = utfx.calculateUTF16asUTF8(stringSource(e), this.noAssert)[1], t += 4 + h; let s = this.buffer.byteLength; if (t > s && this.resize((s *= 2) > t ? s : t), t -= 4 + h, this.littleEndian ? (this.view[t + 3] = h >>> 24 & 255, this.view[t + 2] = h >>> 16 & 255, this.view[t + 1] = h >>> 8 & 255, this.view[t] = h & 255) : (this.view[t] = h >>> 24 & 255, this.view[t + 1] = h >>> 16 & 255, this.view[t + 2] = h >>> 8 & 255, this.view[t + 3] = h & 255), t += 4, utfx.encodeUTF16toUTF8(stringSource(e), function (a) { this.view[t++] = a }.bind(this)), t !== n + 4 + h) throw RangeError(`Illegal range: Truncated data, ${t} == ${t + 4 + h}`); return r ? (this.offset = t, this) : t - n }, ByteBufferPrototype.readIString = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 4 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+4) <= ${this.buffer.byteLength}`) } const r = e, n = this.readUint32(e), h = this.readUTF8String(n, ByteBuffer.METRICS_BYTES, e += 4); return e += h.length, t ? (this.offset = e, h.string) : { string: h.string, length: e - r } }, ByteBuffer.METRICS_CHARS = "c", ByteBuffer.METRICS_BYTES = "b", ByteBufferPrototype.writeUTF8String = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } let n; const h = t; n = utfx.calculateUTF16asUTF8(stringSource(e))[1], t += n; let s = this.buffer.byteLength; return t > s && this.resize((s *= 2) > t ? s : t), t -= n, utfx.encodeUTF16toUTF8(stringSource(e), function (a) { this.view[t++] = a }.bind(this)), r ? (this.offset = t, this) : t - h }, ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String, ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes, ByteBufferPrototype.readUTF8String = function (e, t, r) { typeof t == "number" && (r = t, t = void 0); const n = typeof r > "u"; if (n && (r = this.offset), typeof t > "u" && (t = ByteBuffer.METRICS_CHARS), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal length: ${e} (not an integer)`); if (e |= 0, typeof r != "number" || r % 1 !== 0) throw TypeError(`Illegal offset: ${r} (not an integer)`); if (r >>>= 0, r < 0 || r + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${r} (+0) <= ${this.buffer.byteLength}`) } let h = 0, s = r, a; if (t === ByteBuffer.METRICS_CHARS) { if (a = stringDestination(), utfx.decodeUTF8(function () { return h < e && r < this.limit ? this.view[r++] : null }.bind(this), function (l) { ++h, utfx.UTF8toUTF16(l, a) }), h !== e) throw RangeError(`Illegal range: Truncated data, ${h} == ${e}`); return n ? (this.offset = r, a()) : { string: a(), length: r - s } } else if (t === ByteBuffer.METRICS_BYTES) { if (!this.noAssert) { if (typeof r != "number" || r % 1 !== 0) throw TypeError(`Illegal offset: ${r} (not an integer)`); if (r >>>= 0, r < 0 || r + e > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${r} (+${e}) <= ${this.buffer.byteLength}`) } const l = r + e; if (utfx.decodeUTF8toUTF16(function () { return r < l ? this.view[r++] : null }.bind(this), a = stringDestination(), this.noAssert), r !== l) throw RangeError(`Illegal range: Truncated data, ${r} == ${l}`); return n ? (this.offset = r, a()) : { string: a(), length: r - s } } throw TypeError(`Unsupported metrics: ${t}`) }, ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String, ByteBufferPrototype.writeVString = function (e, t) { const r = typeof t > "u"; if (r && (t = this.offset), !this.noAssert) { if (typeof e != "string") throw TypeError("Illegal str: Not a string"); if (typeof t != "number" || t % 1 !== 0) throw TypeError(`Illegal offset: ${t} (not an integer)`); if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${t} (+0) <= ${this.buffer.byteLength}`) } let n = t, h, s; h = utfx.calculateUTF16asUTF8(stringSource(e), this.noAssert)[1], s = ByteBuffer.calculateVarint32(h), t += s + h; let a = this.buffer.byteLength; if (t > a && this.resize((a *= 2) > t ? a : t), t -= s + h, t += this.writeVarint32(h, t), utfx.encodeUTF16toUTF8(stringSource(e), function (l) { this.view[t++] = l }.bind(this)), t !== n + h + s) throw RangeError(`Illegal range: Truncated data, ${t} == ${t + h + s}`); return r ? (this.offset = t, this) : t - n }, ByteBufferPrototype.readVString = function (e) { const t = typeof e > "u"; if (t && (e = this.offset), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+1) <= ${this.buffer.byteLength}`) } const r = e, n = this.readVarint32(e), h = this.readUTF8String(n.value, ByteBuffer.METRICS_BYTES, e += n.length); return e += h.length, t ? (this.offset = e, h.string) : { string: h.string, length: e - r } }, ByteBufferPrototype.append = function (e, t, r) { (typeof t == "number" || typeof t != "string") && (r = t, t = void 0); const n = typeof r > "u"; if (n && (r = this.offset), !this.noAssert) { if (typeof r != "number" || r % 1 !== 0) throw TypeError(`Illegal offset: ${r} (not an integer)`); if (r >>>= 0, r < 0 || r + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${r} (+0) <= ${this.buffer.byteLength}`) } e instanceof ByteBuffer || (e = ByteBuffer.wrap(e, t)); const h = e.limit - e.offset; if (h <= 0) return this; r += h; let s = this.buffer.byteLength; return r > s && this.resize((s *= 2) > r ? s : r), r -= h, this.view.set(e.view.subarray(e.offset, e.limit), r), e.offset += h, n && (this.offset += h), this }, ByteBufferPrototype.appendTo = function (e, t) { return e.append(this, t), this }, ByteBufferPrototype.writeBytes = ByteBufferPrototype.append, ByteBufferPrototype.assert = function (e) { return this.noAssert = !e, this }, ByteBufferPrototype.capacity = function () { return this.buffer.byteLength }, ByteBufferPrototype.clear = function () { return this.offset = 0, this.limit = this.buffer.byteLength, this.markedOffset = -1, this }, ByteBufferPrototype.clone = function (e) { const t = new ByteBuffer(0, this.littleEndian, this.noAssert); return e ? (t.buffer = new ArrayBuffer(this.buffer.byteLength), t.view = new Uint8Array(t.buffer)) : (t.buffer = this.buffer, t.view = this.view), t.offset = this.offset, t.markedOffset = this.markedOffset, t.limit = this.limit, t }, ByteBufferPrototype.compact = function (e, t) { if (typeof e > "u" && (e = this.offset), typeof t > "u" && (t = this.limit), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); if (e >>>= 0, typeof t != "number" || t % 1 !== 0) throw TypeError("Illegal end: Not an integer"); if (t >>>= 0, e < 0 || e > t || t > this.buffer.byteLength) throw RangeError(`Illegal range: 0 <= ${e} <= ${t} <= ${this.buffer.byteLength}`) } if (e === 0 && t === this.buffer.byteLength) return this; const r = t - e; if (r === 0) return this.buffer = EMPTY_BUFFER, this.view = null, this.markedOffset >= 0 && (this.markedOffset -= e), this.offset = 0, this.limit = 0, this; const n = new ArrayBuffer(r), h = new Uint8Array(n); return h.set(this.view.subarray(e, t)), this.buffer = n, this.view = h, this.markedOffset >= 0 && (this.markedOffset -= e), this.offset = 0, this.limit = r, this }, ByteBufferPrototype.copy = function (e, t) { if (typeof e > "u" && (e = this.offset), typeof t > "u" && (t = this.limit), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); if (e >>>= 0, typeof t != "number" || t % 1 !== 0) throw TypeError("Illegal end: Not an integer"); if (t >>>= 0, e < 0 || e > t || t > this.buffer.byteLength) throw RangeError(`Illegal range: 0 <= ${e} <= ${t} <= ${this.buffer.byteLength}`) } if (e === t) return new ByteBuffer(0, this.littleEndian, this.noAssert); const r = t - e, n = new ByteBuffer(r, this.littleEndian, this.noAssert); return n.offset = 0, n.limit = r, n.markedOffset >= 0 && (n.markedOffset -= e), this.copyTo(n, 0, e, t), n }, ByteBufferPrototype.copyTo = function (e, t, r, n) { let h, s; if (!this.noAssert && !ByteBuffer.isByteBuffer(e)) throw TypeError("Illegal target: Not a ByteBuffer"); if (t = (s = typeof t > "u") ? e.offset : t | 0, r = (h = typeof r > "u") ? this.offset : r | 0, n = typeof n > "u" ? this.limit : n | 0, t < 0 || t > e.buffer.byteLength) throw RangeError(`Illegal target range: 0 <= ${t} <= ${e.buffer.byteLength}`); if (r < 0 || n > this.buffer.byteLength) throw RangeError(`Illegal source range: 0 <= ${r} <= ${this.buffer.byteLength}`); const a = n - r; return a === 0 ? e : (e.ensureCapacity(t + a), e.view.set(this.view.subarray(r, n), t), h && (this.offset += a), s && (e.offset += a), this) }, ByteBufferPrototype.ensureCapacity = function (e) { let t = this.buffer.byteLength; return t < e ? this.resize((t *= 2) > e ? t : e) : this }, ByteBufferPrototype.fill = function (e, t, r) { const n = typeof t > "u"; if (n && (t = this.offset), typeof e == "string" && e.length > 0 && (e = e.charCodeAt(0)), typeof t > "u" && (t = this.offset), typeof r > "u" && (r = this.limit), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal value: ${e} (not an integer)`); if (e |= 0, typeof t != "number" || t % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); if (t >>>= 0, typeof r != "number" || r % 1 !== 0) throw TypeError("Illegal end: Not an integer"); if (r >>>= 0, t < 0 || t > r || r > this.buffer.byteLength) throw RangeError(`Illegal range: 0 <= ${t} <= ${r} <= ${this.buffer.byteLength}`) } if (t >= r) return this; for (; t < r;)this.view[t++] = e; return n && (this.offset = t), this }, ByteBufferPrototype.flip = function () { return this.limit = this.offset, this.offset = 0, this }, ByteBufferPrototype.mark = function (e) { if (e = typeof e > "u" ? this.offset : e, !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal offset: ${e} (not an integer)`); if (e >>>= 0, e < 0 || e + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${e} (+0) <= ${this.buffer.byteLength}`) } return this.markedOffset = e, this }, ByteBufferPrototype.order = function (e) { if (!this.noAssert && typeof e != "boolean") throw TypeError("Illegal littleEndian: Not a boolean"); return this.littleEndian = !!e, this }, ByteBufferPrototype.LE = function (e) { return this.littleEndian = typeof e < "u" ? !!e : !0, this }, ByteBufferPrototype.BE = function (e) { return this.littleEndian = typeof e < "u" ? !e : !1, this }, ByteBufferPrototype.prepend = function (e, t, r) { (typeof t == "number" || typeof t != "string") && (r = t, t = void 0); const n = typeof r > "u"; if (n && (r = this.offset), !this.noAssert) { if (typeof r != "number" || r % 1 !== 0) throw TypeError(`Illegal offset: ${r} (not an integer)`); if (r >>>= 0, r < 0 || r + 0 > this.buffer.byteLength) throw RangeError(`Illegal offset: 0 <= ${r} (+0) <= ${this.buffer.byteLength}`) } e instanceof ByteBuffer || (e = ByteBuffer.wrap(e, t)); const h = e.limit - e.offset; if (h <= 0) return this; const s = h - r; if (s > 0) { const a = new ArrayBuffer(this.buffer.byteLength + s), l = new Uint8Array(a); l.set(this.view.subarray(r, this.buffer.byteLength), h), this.buffer = a, this.view = l, this.offset += s, this.markedOffset >= 0 && (this.markedOffset += s), this.limit += s, r += s } else { const a = new Uint8Array(this.buffer) } return this.view.set(e.view.subarray(e.offset, e.limit), r - h), e.offset = e.limit, n && (this.offset -= h), this }, ByteBufferPrototype.prependTo = function (e, t) { return e.prepend(this, t), this }, ByteBufferPrototype.printDebug = function (e) {
    typeof e != "function" && (e = console.log.bind(console)), e(`${this.toString()}
-------------------------------------------------------------------
${this.toDebug(!0)}`)
}, ByteBufferPrototype.remaining = function () { return this.limit - this.offset }, ByteBufferPrototype.reset = function () { return this.markedOffset >= 0 ? (this.offset = this.markedOffset, this.markedOffset = -1) : this.offset = 0, this }, ByteBufferPrototype.resize = function (e) { if (!this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal capacity: ${e} (not an integer)`); if (e |= 0, e < 0) throw RangeError(`Illegal capacity: 0 <= ${e}`) } if (this.buffer.byteLength < e) { const t = new ArrayBuffer(e), r = new Uint8Array(t); r.set(this.view), this.buffer = t, this.view = r } return this }, ByteBufferPrototype.reverse = function (e, t) { if (typeof e > "u" && (e = this.offset), typeof t > "u" && (t = this.limit), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); if (e >>>= 0, typeof t != "number" || t % 1 !== 0) throw TypeError("Illegal end: Not an integer"); if (t >>>= 0, e < 0 || e > t || t > this.buffer.byteLength) throw RangeError(`Illegal range: 0 <= ${e} <= ${t} <= ${this.buffer.byteLength}`) } return e === t ? this : (Array.prototype.reverse.call(this.view.subarray(e, t)), this) }, ByteBufferPrototype.skip = function (e) { if (!this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError(`Illegal length: ${e} (not an integer)`); e |= 0 } const t = this.offset + e; if (!this.noAssert && (t < 0 || t > this.buffer.byteLength)) throw RangeError(`Illegal length: 0 <= ${this.offset} + ${e} <= ${this.buffer.byteLength}`); return this.offset = t, this }, ByteBufferPrototype.slice = function (e, t) { if (typeof e > "u" && (e = this.offset), typeof t > "u" && (t = this.limit), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); if (e >>>= 0, typeof t != "number" || t % 1 !== 0) throw TypeError("Illegal end: Not an integer"); if (t >>>= 0, e < 0 || e > t || t > this.buffer.byteLength) throw RangeError(`Illegal range: 0 <= ${e} <= ${t} <= ${this.buffer.byteLength}`) } const r = this.clone(); return r.offset = e, r.limit = t, r }, ByteBufferPrototype.toBuffer = function (e) { let t = this.offset, r = this.limit; if (!this.noAssert) { if (typeof t != "number" || t % 1 !== 0) throw TypeError("Illegal offset: Not an integer"); if (t >>>= 0, typeof r != "number" || r % 1 !== 0) throw TypeError("Illegal limit: Not an integer"); if (r >>>= 0, t < 0 || t > r || r > this.buffer.byteLength) throw RangeError(`Illegal range: 0 <= ${t} <= ${r} <= ${this.buffer.byteLength}`) } if (!e && t === 0 && r === this.buffer.byteLength) return this.buffer; if (t === r) return EMPTY_BUFFER; const n = new ArrayBuffer(r - t); return new Uint8Array(n).set(new Uint8Array(this.buffer).subarray(t, r), 0), n }, ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer, ByteBufferPrototype.toString = function (e, t, r) { if (typeof e > "u") return `ByteBufferAB(offset=${this.offset},markedOffset=${this.markedOffset},limit=${this.limit},capacity=${this.capacity()})`; switch (typeof e == "number" && (e = "utf8", t = e, r = t), e) { case "utf8": return this.toUTF8(t, r); case "base64": return this.toBase64(t, r); case "hex": return this.toHex(t, r); case "binary": return this.toBinary(t, r); case "debug": return this.toDebug(); case "columns": return this.toColumns(); default: throw Error(`Unsupported encoding: ${e}`) } }; const lxiv = function () { "use strict"; const e = {}, t = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47], r = []; for (let n = 0, h = t.length; n < h; ++n)r[t[n]] = n; return e.encode = function (n, h) { let s, a; for (; (s = n()) !== null;)h(t[s >> 2 & 63]), a = (s & 3) << 4, (s = n()) !== null ? (a |= s >> 4 & 15, h(t[(a | s >> 4 & 15) & 63]), a = (s & 15) << 2, (s = n()) !== null ? (h(t[(a | s >> 6 & 3) & 63]), h(t[s & 63])) : (h(t[a & 63]), h(61))) : (h(t[a & 63]), h(61), h(61)) }, e.decode = function (n, h) { let s, a, l; function o(g) { throw Error(`Illegal character code: ${g}`) } for (; (s = n()) !== null;)if (a = r[s], typeof a > "u" && o(s), (s = n()) !== null && (l = r[s], typeof l > "u" && o(s), h(a << 2 >>> 0 | (l & 48) >> 4), (s = n()) !== null)) { if (a = r[s], typeof a > "u") { if (s === 61) break; o(s) } if (h((l & 15) << 4 >>> 0 | (a & 60) >> 2), (s = n()) !== null) { if (l = r[s], typeof l > "u") { if (s === 61) break; o(s) } h((a & 3) << 6 >>> 0 | l) } } }, e.test = function (n) { return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(n) }, e }(); ByteBufferPrototype.toBase64 = function (e, t) { if (typeof e > "u" && (e = this.offset), typeof t > "u" && (t = this.limit), e = e | 0, t = t | 0, e < 0 || t > this.capacity || e > t) throw RangeError("begin, end"); let r; return lxiv.encode(function () { return e < t ? this.view[e++] : null }.bind(this), r = stringDestination()), r() }, ByteBufferPrototype.toBinary = function (e, t) { if (typeof e > "u" && (e = this.offset), typeof t > "u" && (t = this.limit), e |= 0, t |= 0, e < 0 || t > this.capacity() || e > t) throw RangeError("begin, end"); if (e === t) return ""; let r = [], n = []; for (; e < t;)r.push(this.view[e++]), r.length >= 1024 && (n.push(String.fromCharCode.apply(String, r)), r = []); return n.join("") + String.fromCharCode.apply(String, r) }, ByteBufferPrototype.toDebug = function (e) {
    let t = -1, r = this.buffer.byteLength, n, h = "", s = "", a = ""; for (; t < r;) {
        if (t !== -1 && (n = this.view[t], n < 16 ? h += `0${n.toString(16).toUpperCase()}` : h += n.toString(16).toUpperCase(), e && (s += n > 32 && n < 127 ? String.fromCharCode(n) : ".")), ++t, e && t > 0 && t % 16 === 0 && t !== r) {
            for (; h.length < 3 * 16 + 3;)h += " "; a += `${h + s}
`, h = s = ""
        } t === this.offset && t === this.limit ? h += t === this.markedOffset ? "!" : "|" : t === this.offset ? h += t === this.markedOffset ? "[" : "<" : t === this.limit ? h += t === this.markedOffset ? "]" : ">" : h += t === this.markedOffset ? "'" : e || t !== 0 && t !== r ? " " : ""
    } if (e && h !== " ") {
        for (; h.length < 3 * 16 + 3;)h += " "; a += `${h + s}
`} return e ? a : h
}, ByteBufferPrototype.toHex = function (e, t) { if (e = typeof e > "u" ? this.offset : e, t = typeof t > "u" ? this.limit : t, !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); if (e >>>= 0, typeof t != "number" || t % 1 !== 0) throw TypeError("Illegal end: Not an integer"); if (t >>>= 0, e < 0 || e > t || t > this.buffer.byteLength) throw RangeError(`Illegal range: 0 <= ${e} <= ${t} <= ${this.buffer.byteLength}`) } let r = new Array(t - e), n; for (; e < t;)n = this.view[e++], n < 16 ? r.push("0", n.toString(16)) : r.push(n.toString(16)); return r.join("") }; const utfx = function () { "use strict"; const e = {}; return e.MAX_CODEPOINT = 1114111, e.encodeUTF8 = function (t, r) { let n = null; for (typeof t == "number" && (n = t, t = function () { return null }); n !== null || (n = t()) !== null;)n < 128 ? r(n & 127) : n < 2048 ? (r(n >> 6 & 31 | 192), r(n & 63 | 128)) : n < 65536 ? (r(n >> 12 & 15 | 224), r(n >> 6 & 63 | 128), r(n & 63 | 128)) : (r(n >> 18 & 7 | 240), r(n >> 12 & 63 | 128), r(n >> 6 & 63 | 128), r(n & 63 | 128)), n = null }, e.decodeUTF8 = function (t, r) { let n, h, s, a, l = function (o) { o = o.slice(0, o.indexOf(null)); const g = Error(o.toString()); throw g.name = "TruncatedError", g.bytes = o, g }; for (; (n = t()) !== null;)if (!(n & 128)) r(n); else if ((n & 224) === 192) (h = t()) === null && l([n, h]), r((n & 31) << 6 | h & 63); else if ((n & 240) === 224) ((h = t()) === null || (s = t()) === null) && l([n, h, s]), r((n & 15) << 12 | (h & 63) << 6 | s & 63); else if ((n & 248) === 240) ((h = t()) === null || (s = t()) === null || (a = t()) === null) && l([n, h, s, a]), r((n & 7) << 18 | (h & 63) << 12 | (s & 63) << 6 | a & 63); else throw RangeError(`Illegal starting byte: ${n}`) }, e.UTF16toUTF8 = function (t, r) { let n, h = null; for (; (n = h !== null ? h : t()) !== null;) { if (n >= 55296 && n <= 57343 && (h = t()) !== null && h >= 56320 && h <= 57343) { r((n - 55296) * 1024 + h - 56320 + 65536), h = null; continue } r(n) } h !== null && r(h) }, e.UTF8toUTF16 = function (t, r) { let n = null; for (typeof t == "number" && (n = t, t = function () { return null }); n !== null || (n = t()) !== null;)n <= 65535 ? r(n) : (n -= 65536, r((n >> 10) + 55296), r(n % 1024 + 56320)), n = null }, e.encodeUTF16toUTF8 = function (t, r) { e.UTF16toUTF8(t, function (n) { e.encodeUTF8(n, r) }) }, e.decodeUTF8toUTF16 = function (t, r) { e.decodeUTF8(t, function (n) { e.UTF8toUTF16(n, r) }) }, e.calculateCodePoint = function (t) { return t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4 }, e.calculateUTF8 = function (t) { let r, n = 0; for (; (r = t()) !== null;)n += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4; return n }, e.calculateUTF16asUTF8 = function (t) { let r = 0, n = 0; return e.UTF16toUTF8(t, function (h) { ++r, n += h < 128 ? 1 : h < 2048 ? 2 : h < 65536 ? 3 : 4 }), [r, n] }, e }(); ByteBufferPrototype.toUTF8 = function (e, t) { if (typeof e > "u" && (e = this.offset), typeof t > "u" && (t = this.limit), !this.noAssert) { if (typeof e != "number" || e % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); if (e >>>= 0, typeof t != "number" || t % 1 !== 0) throw TypeError("Illegal end: Not an integer"); if (t >>>= 0, e < 0 || e > t || t > this.buffer.byteLength) throw RangeError(`Illegal range: 0 <= ${e} <= ${t} <= ${this.buffer.byteLength}`) } let r; try { utfx.decodeUTF8toUTF16(function () { return e < t ? this.view[e++] : null }.bind(this), r = stringDestination()) } catch { if (e !== t) throw RangeError(`Illegal range: Truncated data, ${e} != ${t}`) } return r() }, globalThis.ByteBuffer = ByteBuffer; const AttributeType = Object.freeze({ Uninitialized: 0, Uint32: 1, Int32: 2, Float: 3, String: 4, Vector2: 5, EntityType: 6, ArrayVector2: 7, ArrayUint32: 8, Uint16: 9, Uint8: 10, Int16: 11, Int8: 12, Uint64: 13, Int64: 14, Double: 15 }), ParameterType = Object.freeze({ Uint32: 0, Int32: 1, Float: 2, String: 3, Uint64: 4, Int64: 5 }), PacketIds = Object.freeze({ PACKET_ENTITY_UPDATE: 0, PACKET_PLAYER_COUNTER_UPDATE: 1, PACKET_SET_WORLD_DIMENSIONS: 2, PACKET_INPUT: 3, PACKET_ENTER_WORLD: 4, PACKET_PRE_ENTER_WORLD: 5, PACKET_ENTER_WORLD2: 6, PACKET_PING: 7, PACKET_RPC: 9 }); class Codec { attributeMaps = {}; entityTypeNames = {}; rpcMaps = []; rpcMapsByName = {}; sortedUidsByType = {}; removedEntities = {}; absentEntitiesFlags = []; updatedEntityFlags = []; attributeTypeHandlers = { [AttributeType.Uint32]: t => t.readUint32(), [AttributeType.Int32]: t => t.readInt32(), [AttributeType.Float]: t => t.readInt32() / 100, [AttributeType.String]: t => this.safeReadVString(t), [AttributeType.Vector2]: t => ({ x: t.readInt32() / 100, y: t.readInt32() / 100 }), [AttributeType.ArrayVector2]: t => this.readArray(t, AttributeType.Vector2), [AttributeType.ArrayUint32]: t => this.readArray(t, AttributeType.Uint32), [AttributeType.Uint16]: t => t.readUint16(), [AttributeType.Uint8]: t => t.readUint8(), [AttributeType.Int16]: t => t.readInt16(), [AttributeType.Int8]: t => t.readInt8(), [AttributeType.Uint64]: t => t.readUint32() + t.readUint32() * 4294967296, [AttributeType.Int64]: t => this.readInt64OrDouble(t), [AttributeType.Double]: t => this.readInt64OrDouble(t, 100) }; encode(t, r) { const n = new ByteBuffer(100, !0); switch (t) { case PacketIds.PACKET_ENTER_WORLD: n.writeUint8(PacketIds.PACKET_ENTER_WORLD), this.encodeEnterWorld(n, r); break; case PacketIds.PACKET_ENTER_WORLD2: n.writeUint8(PacketIds.PACKET_ENTER_WORLD2); break; case PacketIds.PACKET_INPUT: n.writeUint8(PacketIds.PACKET_INPUT), this.encodeInput(n, r); break; case PacketIds.PACKET_PING: n.writeUint8(PacketIds.PACKET_PING), this.encodePing(n, r); break; case PacketIds.PACKET_RPC: n.writeUint8(PacketIds.PACKET_RPC), this.encodeRpc(n, r); break }return n.flip(), n.compact(), n.toArrayBuffer(!1) } decode(t) { const r = ByteBuffer.wrap(t); r.littleEndian = !0; const n = r.readUint8(); let h; switch (n) { case PacketIds.PACKET_ENTER_WORLD: h = this.decodeEnterWorldResponse(r); break; case PacketIds.PACKET_ENTITY_UPDATE: h = this.decodeEntityUpdate(r); break; case PacketIds.PACKET_PING: h = this.decodePing(r); break; case PacketIds.PACKET_RPC: h = this.decodeRpc(r); break }return h.opcode = n, h } safeReadVString(t) { let r = t.offset; const n = t.readVarint32(r); try { const s = t.readUTF8String.bind(t)(n.value, ByteBuffer.METRICS_BYTES, r += n.length); return r += s.length, t.offset = r, s.string } catch { return r += n.value, t.offset = r, "?" } } decodeEnterWorldResponse(t) { const r = t.readUint32(), n = t.readUint32(), h = t.readUint32(), s = { allowed: r, uid: n, startingTick: h, tickRate: t.readUint32(), effectiveTickRate: t.readUint32(), players: t.readUint32(), maxPlayers: t.readUint32(), chatChannel: t.readUint32(), effectiveDisplayName: this.safeReadVString(t), x1: t.readInt32(), y1: t.readInt32(), x2: t.readInt32(), y2: t.readInt32() }, a = t.readUint32(); this.attributeMaps = {}, this.entityTypeNames = {}; for (let o = 0; o < a; o += 1) { const g = [], u = t.readUint32(), c = t.readVString(), f = t.readUint32(); for (let y = 0; y < f; y += 1) { const w = t.readVString(), p = t.readUint32(); g.push({ name: w, type: p }) } this.attributeMaps[u] = g, this.entityTypeNames[u] = c, this.sortedUidsByType[u] = [] } const l = t.readUint32(); this.rpcMaps = [], this.rpcMapsByName = {}; for (let o = 0; o < l; o += 1) { const g = t.readVString(), u = t.readUint8(), c = t.readUint8() != 0, f = []; for (let w = 0; w < u; w += 1) { const p = t.readVString(), d = t.readUint8(); f.push({ name: p, type: d }) } const y = { name: g, parameters: f, isArray: c, index: this.rpcMaps.length }; this.rpcMaps.push(y), this.rpcMapsByName[g] = y } return s } readArray(t, r) { const n = t.readInt32(), h = [], s = this.attributeTypeHandlers[r]; if (!s) throw new Error(`Unsupported array element type: ${r}`); for (let a = 0; a < n; a += 1)h.push(s(t)); return h } readInt64OrDouble(t, r = 1) { const n = BigInt(t.readUint32()), h = BigInt(t.readInt32()), s = h >= 0n ? n + h * 0x100000000n : -n + h * 0x100000000n; return Number(s) / r } updateEntityData(t, r, n) { const h = this.attributeMaps[r], s = { uid: n }; this.updatedEntityFlags.length = 0; for (let a = 0; a < Math.ceil(h.length / 8); a += 1)this.updatedEntityFlags.push(t.readUint8()); for (let a = 0; a < h.length; a += 1) { const l = h[a], o = Math.floor(a / 8), g = a % 8; this.updatedEntityFlags[o] & 1 << g && (s[l.name] = this.readAttributeValue(t, l)) } return s } readAttributeValue(t, r) { const n = this.attributeTypeHandlers[r.type]; return n ? n(t) : (console.error(`Unsupported attribute type: ${r.type} for attribute ${r.name}`), null) } decodeEntityUpdate(t) { const r = t.readUint32(); this.updateRemovedEntities(t); const n = { tick: r, entities: new Map, byteSize: t.capacity() }; for (this.addBrandNewEntities(t), this.cleanSortedUidsByType(); t.remaining();) { const h = t.readUint32(); if (!(h in this.attributeMaps)) throw new Error(`Entity type is not in attribute map: ${h}`); const s = Math.floor((this.sortedUidsByType[h].length + 7) / 8); this.absentEntitiesFlags.length = 0; for (let a = 0; a < s; a += 1)this.absentEntitiesFlags.push(t.readUint8()); for (let a = 0; a < this.sortedUidsByType[h].length; a += 1) { const l = this.sortedUidsByType[h][a]; if (this.absentEntitiesFlags[Math.floor(a / 8)] & 1 << a % 8) { n.entities[l] = !0; continue } n.entities[l] = this.updateEntityData(t, h, l) } } return n } cleanSortedUidsByType() { for (const [t, r] of Object.entries(this.sortedUidsByType)) this.sortedUidsByType[t] = r.filter(n => !(n in this.removedEntities)).sort((n, h) => n - h) } updateRemovedEntities(t) { const r = t.readVarint32(); Object.keys(this.removedEntities).forEach(n => delete this.removedEntities[n]); for (let n = 0; n < r; n += 1) { const h = t.readUint32(); this.removedEntities[h] = !0 } } addBrandNewEntities(t) { const r = t.readVarint32(); for (let n = 0; n < r; n += 1) { const h = t.readVarint32(), s = t.readUint32(); for (let a = 0; a < h; a += 1) { const l = t.readUint32(); this.sortedUidsByType[s] || (this.sortedUidsByType[s] = []), this.sortedUidsByType[s].push(l) } } } decodePing() { return {} } encodeRpc(t, r) { if (!(r.name in this.rpcMapsByName)) { if (r.name == "Metrics") return; throw new Error(`RPC not in map: ${r.name}`) } const n = this.rpcMapsByName[r.name]; t.writeUint32(n.index); for (let h = 0; h < n.parameters.length; h += 1) { const s = r[n.parameters[h].name]; switch (n.parameters[h].type) { case ParameterType.Float: t.writeInt32(Math.floor(s * 100)); break; case ParameterType.Int32: t.writeInt32(s); break; case ParameterType.String: t.writeVString(s); break; case ParameterType.Uint32: t.writeUint32(s); break } } } decodeRpcObject(t, r) { const n = {}; for (let h = 0; h < r.length; h += 1)switch (r[h].type) { case ParameterType.Uint32: n[r[h].name] = t.readUint32(); break; case ParameterType.Int32: n[r[h].name] = t.readInt32(); break; case ParameterType.Float: n[r[h].name] = t.readInt32() / 100; break; case ParameterType.String: n[r[h].name] = this.safeReadVString(t); break; case ParameterType.Uint64: n[r[h].name] = t.readUint32() + t.readUint32() * 4294967296; break }return n } decodeRpc(t) { const r = t.readUint32(), n = this.rpcMaps[r], h = { name: n.name, response: null }; if (!n.isArray) h.response = this.decodeRpcObject(t, n.parameters); else { const s = [], a = t.readUint16(); for (let l = 0; l < a; l += 1)s.push(this.decodeRpcObject(t, n.parameters)); h.response = s } return h } encodeEnterWorld(t, r) { t.writeVString(r.displayName); const n = new Uint8Array(r.extra); for (let h = 0; h < r.extra.byteLength; h += 1)t.writeUint8(n[h]) } encodeInput(t, r) { t.writeVString(JSON.stringify(r)) } encodePing(t) { t.writeUint8(0) } }

const codecInstances = new Map();
onmessage = function ({ data }) {
    const { id, task, buffer, opcode } = data;

    let codec,
        result;
    switch (task) {
        case "initialise":
            codec = new Codec();
            codecInstances.set(id, codec);
            break;
        case "decode":
            codec = codecInstances.get(id);
            if (opcode === 0) {
                result = JSON.stringify(codec.decode(buffer));
            } else {
                result = codec.decode(buffer);
            }
            self.postMessage({
                id: id,
                action: "decoded",
                opcode: opcode,
                result: result
            });
            break;
        case "encode":
            codec = codecInstances.get(id);
            self.postMessage({
                id: id,
                action: "encoded",
                opcode: opcode,
                result: codec.encode(opcode, buffer)
            });
            break;
    }
}